#! /bin/sh
exit_version() {
	cat << ===; exit
$APP version 2025.186
Copyright (c) 2025 Guenther Brunthaler. All rights reserved.

This script is free software.
Distribution is permitted under the terms of the GPLv3.
===
}
APP=${0##*/}

exit_help() {
	cat << ===; echo; exit_version
$APP - create private mount-point directories in /media for the
current user

Usage: $APP [ <options> ] [ -- ] [ <subdir_names> ]

Create (unless it already exists) directory /media/$USER/mnt with
appropriate permissions for $USER to create further mount
directories there, e.g. for FUSE-based filesystems.

If any arguments (no complete pathnames, just names without "/")
are specified, sub-directories of those names will created as
subdirectories (unless they already exist) of /media/$USER/mnt,
ready to be used as mount points for USE-based filesystems (e.g.
sshfs).

In fact, for the sake of comfort, complete pathnames as arguments
are actually allowed as arguments. But in this case, only the
basename of every pathname is used for creating subdirectories.
Everything up to the last "/" in the pathame will be removed
before using the remainder as a subdirectory name to create.

Supported command line options:

-n: Dry run. Show what would be done, but don't actually do
    anything.
-h: Display help and exit.
-V: Display version information and exit.
===
}

set -e
trap 'test $? = 0 || echo "\"$0\" failed!" >& 2' 0

dry_run=false
force=false
quiet=false
while getopts qfnhV opt
do
	case $opt in
		n) dry_run=true;;
		q) quiet=true;;
		f) force=true;;
		V) exit_version;;
		h) exit_help;;
		*) false || exit
	esac
done
shift `expr $OPTIND - 1 || :`

inform() {
	$quiet && return
	"$@"
}

run() {
	$dry_run && set echo SIMULATION: "$@"
	"$@"
}

d=/media
test -x "$d"
case `stat -f -c %T -- "$d"` in
	tmpfs | ramfs) ;;
	*) $force || exit
esac

me=`id -un`
test "$me"
d=$d/$me

if test ! -e "$d"
then
	run sudo mkdir -m 750 "$d"
	run sudo chgrp -- "$me" "$d"
fi

d=$d/mnt
if test ! -e "$d"
then
	run sudo mkdir -m 770 "$d"
	run sudo chgrp -- "$me" "$d"
fi

command -v namei > /dev/null 2>& 1 && namei=$? || namei=$?
first=true
for sd
do
	sd=${sd##*/}
	sd=$d/$sd
	if test ! -e "$sd"
	then
		run mkdir -m 700 "$sd"
	fi
	if $first
	then
		first=false
	else
		inform echo
	fi
	inform run ls -ld "$sd"
	case $namei in
		0) inform echo; inform run namei -l "$sd"
	esac
done

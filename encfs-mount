#! /bin/sh
exit_version() {
	wr -s <<- . && exit
	$APP version 13.245

	(c) 2008 - 2013 by Guenther Brunthaler.
	This script is free software.
	Distribution is permitted under the terms of the GPLv3.
.
}
APP=${0##*/}


die() {
	echo "ERROR: $*" >& 2
	false || exit
}


run() {
	"$@" && return
	die "Could not execute >>>$*<<<: return code ${?}!"
}


system() {
	REPLY=`run "$@"` || exit
}


wr() {
	test -z "$*" && set -- -c
	fmt -w "$LINEWIDTH" "$@"
}
LINEWIDTH=; tty -s && LINEWIDTH=`tput cols` || LINEWIDTH=; : ${LINEWIDTH:=70}


exit_help() {
	wr <<- .
	$APP -
	   mount or unmount encfs

	$APP is an enfcs helper utility. ("encfs" is a popular encrypted
	filesystem in userspace based on the "fuse" kernel module.)

	$APP mounts an encrypted encfs container on a mount point directory
	for the current user. Alternatively, $APP can unmount a mounted
	directory.

	And because directories in EncFS cannot be used as mount points for
	nested encrypted file systems, $APP also supports following symlinks
	from to actual mount-point directories somewhere else.

	It also supports setting up such external mount points and creating a
	symlink to them automatically, using a randomly-generated mount point
	name which does not reveal anything to an observer when the mount
	point is not currently in use.

	Usage: $APP
	   [ options ... ] <directory> [ <mount_point_base_dir> ]

	where

	<directory>: Either the mount point directory or the encrypted encfs
	container directory. If the base name of <directory> has a .encfs
	suffix, it is assumed to be an encrypted enfcs container directory.
	Otherwise, it is considered to be the mount point directory. In either
	case, both directories must exist: <name> and <name>.encfs, and
	<directory> may specify either of them. The mount-point directory can
	also be a symlink to some other directory. In this case, the decryped
	view into the encrypted filesystem will be mounted where this symlink
	points to. Neither <name> nor <name>.encfs need to exist. They will be
	created in the current directory if not already existing, allowing
	access to the current user only.

	<mount_point_base_dir>: This is only relevant if the <name> specified
	by <directory> does not yet exist and will be ignored otherwise. Its
	presence modifies the behaviour descripted for <directory> in this
	case. <name>.encfs will still be created in the current directory if
	not present, but <name> will be created as a relative symlink instead,
	referring to a automatically created new mount point created as a
	subdirectory of <mount_point_base_dir> with a randomly-generated name.

	--urandom, u: This is only relevant for generating a mount point name
	randomly, as described in the section about <mount_point_base_dir>.
	Without, this option /dev/random will be used as source for the random
	name. This option changes this to using /dev/urandom instead.

	--help, -h: Show this usage help.

	--version, -V: Show the version of this script.

	--non-empty, --nonempty, --ne, -e: Allow the mount point directory to
	be non-empty before the mounting. Normally, this will result in an
	error.

	--read-only, --readonly, --ro, -r: Mount as read-only.

	$APP will mount the encfs directory unless already mounted; in the
	latter case, it will unmount the directory instead.

	When unmounting an already-mounted encfs directory, the fuse kernel
	module will also be unloaded if it is no longer required. The latter
	requires that "sudo rmmod fuse" has been set up by the administrator
	to actually work.

	Before trying to mount the encfs container directory, $APP will load
	the "fuse" kernel module if it is not already loaded. This requires
	that "sudo modprobe fuse" has been set up by the administrator to
	actually work.

	Note that encfs might possibly not to be fully trusted, because it has
	been built on some questionable design decisions such as CBC chaining
	mode and a rather restricted set of encryption algorithms.

	It is therefore recommended to never use encfs on its own for really
	important sensitive data, but rather on top of an already encrypted
	volume (such as LUKS or TrueCrypt).

	In such scenarios, encfs can add an additional layer of security on
	top of the already encrypted volumes. Encfs has also the advantage
	that it works on a per-user basis and does not require administrator
	rights for mounting or unmounting.

.
	exit_version
}


canon() {
	system readlink -f -- "$1"
}


chkdir() {
	test x`run stat -c %a "$1"` = x700 \
		|| die "$2 directory must be chmod 700!"
}


get_device() {
	run stat -c '%d' "$1"
}


is_mounted() {
	test x`get_device "$1"` != x`get_device "$1/.."`
}


random_name() {
	{
		echo "obase=35; ibase=16"
		run od -An -N16 -vtx1 "$random_source" \
		| tr -d ' ' \
		| {
			s=
			while IFS= read LINE
			do
				s=$s$LINE
			done
			echo $s
		} \
		| run tr '[:lower:]' '[:upper:]'
	} | LC_ALL=C POSIXLY_CORRECT=1 run bc \
	| {
		s=
		while IFS= read -r line
		do
			s=$s${line%"\\"}
		done
		run printf '%s' "$s"
	} | LC_ALL=C POSIXLY_CORRECT=1 run awk '
		{
			alphabet= "0123456789abcdefghijklmnpqrstuvwxyz"
			out= ""
			for (i= 1; i < NF + 1; ++i) {
				out= out substr(alphabet, $i + 1, 1)
			}
			print out
		}
	'
}


NONEMPTY=
READONLY=
random_source=/dev/random
while :
do
	case $1 in
		--urandom | -u) random_source=/dev/urandom;;
		--nonempty | --non-empty | --ne | -e) NONEMPTY=Y;;
		--read-only | --readonly | --ro | -r) READONLY=Y;;
		--help | -h) exit_help;;
		--version | -V) exit_version;;
		--) shift; break;;
		-*) die "Unsupported option '$1'!";;
		*) break;;
	esac
	shift
done
dir=${1:?"Invalid arguments - use --help for showing help!"}
shift
MBASE=$1; test $# != 0 && shift
test $# = 0 || die "Too many arguments - use --help for showing help!"
case $dir in
	*.encfs) ENC=$dir; MOUNT=${dir%.*};;
	*) MOUNT=$dir; ENC=$dir.encfs
esac
test -e "$ENC" || run mkdir -m 700 "$ENC"
if test ! -e "$MOUNT"
then
	if test -n "$MBASE"
	then
		MBASE=${MBASE%%/}
		run test -d "$MBASE/."
		while :
		do
			mp=$MBASE/`random_name`
			test ! -e "$mp" && break
		done
		run mkdir -m 700 "$mp"
		canon "$mp"
		run ln -s "$REPLY" "$MOUNT"
		run optimize-symlinks-as-relative -q "$MOUNT"
	else
		run mkdir -m 700 "$MOUNT"
	fi
fi
run test -d "$MOUNT" # Can also be a symlink!
if test x"${MOUNT%.encfs}" = x"$MOUNT"; then
	ENC=$MOUNT.encfs
	run test -d "$ENC"
else
	ENC=$MOUNT
	MOUNT=${ENC%.encfs}
	run test -d "$MOUNT"
fi
# Resolve symlinks only after determining the names.
canon "$MOUNT"; MOUNT=$REPLY
canon "$ENC"; ENC=$REPLY
chkdir "$ENC" "Associated .encfs"
chkdir "$MOUNT" "Mount point"
if is_mounted "$MOUNT"; then
	echo "Trying to unmount '$ENC' from '$MOUNT'..." | wr
	run fusermount -u "$MOUNT"
	if test x`lsmod | grep ^fuse | awk '{print $3}'` = x0; then
		sudo rmmod fuse
	fi
else
	run lsmod | grep -s ^fuse > /dev/null || run sudo modprobe fuse
	echo "Trying to mount '$ENC' as '$MOUNT'..." | wr
	set --
	test -n "$NONEMPTY" && set -- "$@" -o nonempty
	test -n "$READONLY" && set -- "$@" -o ro
	run encfs "$ENC" "$MOUNT" -- "$@"
fi
echo "Success!"

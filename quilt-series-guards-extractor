#! /bin/sh
show_version() {
	wr <<- .
	$APP version 15.213

	(c) 2010 - 2015 by Guenther Brunthaler.\n
	Distribution is permitted under the terms of the GPLv3.
.
}
APP=${0##*/}


show_help() {
	wr <<- .
	$APP - reconstruct a configuration file for "guards" from a of patch
	series file and from information which has previously been injected
	into the patch file headers.
	
	Usage: $APP [ options ] [ <patch_directory> ]
	
	$APP scans the headers of the patch files in <patch_directory>
	for lines which look like this:

	Guards-Tag: Line = 3, Condition = +some_tag
	
	and uses this to reconstruct a configuration files for the "guards"
	utility which is shipped as part of the "quilt" patch management tool
	suite.
	
	If <patch_directory> is not specified but the variable \$QUILT_PATCHES
	is set, its contents are used as the patches directory.
	
	Otherwise, if a subdirectory "patches" exists in the current
	directory, this is used as the patches directory. If this directory
	also does not exist, the current directory is assumed to be the
	patches directory.

	In order to find out which of the files in the patch directory are
	actually patches and in which order they are intended to be applied, a
	file with the name "series" must be present in the patch directory.
	
	This "series" file must list all the patches, one patch per line, in
	the intended order for the patches to be applied.
	
	The "series" file is allowed to contain relative path names if the
	corresponding patch files have also been structured into
	subdirectories of the patches directory.
	
	By default, the reconstructed "guards" configuration file will be
	written to standard output and no files will be modified.
	

	Options:
	
	-o <output_file>: Instead of writing the reconstructed "guards"
	control file to standard output, it is written to <output_file>.
	
	-g: Similar to -o, but using a file "$DEFAULT_OUTPUT_NAME" in
	the patches directory as the output file. Note that a file with
	this name must exist for the -d option to work.
	
	-d: Delete the "Guards-Tag:"-lines from the patch file headers of the
	patches specified in the "series" file. This is intended to remove the
	injected information after extracting and storing it. As a security
	precaution, this option requires a file to exist at the same name and
	location as the file generated by the -g option. Typically, one first
	uses -g to regenerate and store a "guards" configuration file, and
	only after this has been successful, -d is used to removed the
	"Guards-Tag:"-lines. It is allowed to specifiy -g and -d at the same
	time. This will first generate the output file, and remove the tag
	lines only if there was no error during reconstruction of the "guards"
	configuration file.
	
	-N: Only relevant if -d has also been specified. Normally, the
	original patch files will be replaced by the updated patch files. If
	this option is used, new patch files are written instead. Those files
	have the same name as the original patch files, except that ".new"
	will be appended to the original name. The original files will not be
	modified.

	-K: Only relevant if -d has also been specified. Before writing out
	the updated patch files, the original files are renamed into backup
	files by adding the suffix ".orig" to the original names. Normally
	those backups will be removed after successfully updating each patch
	file. This option suppresses the removal of the backup files, keeping
	them. This option has no effect if the -N option is also active,
	because then there will be no backup files to be removed anyway.
	
	-O: Only relevant if -d has also been specified. Allow overwriting of
	output files which already exist. As explained for the -N and -K
	options, files with the same basic name as a patch file but with the
	additional suffix ".new" or ".orig" might need to be created.
	Normally, already existing files with those names will never be
	overwritten by $APP, resulting in an error if such files already
	exist. With -O, any such files will be overwritten silently instead.

	-v: Be verbose. Only relevant if -d has also been specified. Displays
	the names of the modified patch file as they are written.

	-h: Show this help.

	-V: Show only the version information.
.
	echo
	show_version
}


die() {
	echo "ERROR: $*" >& 2
	false; exit
}


run() {
	"$@" || die "Could not execute >>>$*<<<: Return code ${?}!"
}


system() {
	REPLY=`run "$@"` || exit
}


print() {
	run printf '%s' "$*"
}


println() {
	run printf '%s\n' "$*"
}


wr() {
	local REPLY
	while IFS= read -r REPLY
	do
		{
			while test -n "$REPLY" || IFS= read -r REPLY
			do
				ORIG=$REPLY; REPLY=${REPLY%\\n}
				println "$REPLY"
				test x"$ORIG" != x"$REPLY"  && break
				REPLY=
			done
		} | run fmt -w "$LINEWIDTH" || exit
	done
}
# Determine up line width to use for output.
LINEWIDTH=; tty -s && LINEWIDTH=`tput cols` || LINEWIDTH=; : ${LINEWIDTH:=70}


# Set $REPLY to a quoted representation of all the arguments
# ready for 'eval set -- $REPLY' to reconstruct the arguments.
qin() {
	local REST S Q R
	REPLY=
	for S
	do
		Q=; R=
		while test -n "$S"
		do
			REST=${S#?}; S=${S%"$REST"}
			case $S in
				\$ | \` | \" | \\) S=\\$S;;
				" " | "$NL" | "$TAB") Q=Y;;
			esac
			R=$R$S; S=$REST
		done
		test -n "$Q" && R=\"$R\"
		REPLY=$REPLY${REPLY:+ }$R
	done
}
# Construct required constants $TAB and $NL.
NL=`printf '\t\n:'`; TAB=${NL%??}; NL=${NL%?}; NL=${NL#?}


# Make sure the directory components before the basename exist.
mkbasedirs() {
	local PARENT
	PARENT=${1%/*}
	test x"$PARENT" = x"$1" && return
	test -d "$PARENT" && return
	mkbasedirs "$PARENT"
	run mkdir -- "$PARENT"
}


close7() {
	exec 7>& -
	OUT7=
}


cleanup() {
	test -n "$OUT7" && close7
	test -z "$DEBUG" && rm -r "$TD"
}


sed1() {
	local S A OIFS
	S=$1; shift
	OIFS=$IFS; IFS=; A=$*; IFS=$OIFS
	println "$S" | run sed -e "$A"
}


overwrite_check() {
	test ! -e "$1" && return
	test -z "$OVERWRITE_OLD_BACKUPS" && {
		die "Output file \"$1\" already exists" \
			"- use -O to enable" \
			"overwriting of files!"
	}
	run rm -- "$1"
}


# Sets $REPLY to "$LINE:$CONDITION"
parse_guards_tag() {
	system sed1 "$1" 's/' \
		'^Guards-Tag:[[:space:]]*' \
		'Line[[:space:]]*=[[:space:]]*' \
		'\([1-9][0-9]*\)[[:space:]]*,[[:space:]]*' \
		'Condition[[:space:]]*=[[:space:]]*' \
		'\([-+]!\?[-_[:alnum:]]\+\)' \
		'[[:space:]]*$' \
		'/\1:\2/'
	case $REPLY in
		[0-9]*) true;;
		*) false;;
	esac
}


extract() {
	local PATCH
	local REPLY OUTBASE INFILE LINE SEARCH STRIPPED COND ANY TAG
	PATCH=$1
	OUTBASE=$TD/p/$PATCH
	STRIPPED=$TD/s/$PATCH
	TAG=$TD/t/$PATCH
	INFILE=$PATCHES_DIR/$PATCH
	test -e "$TAG" && return # Multiple occurrences in series file.
	mkbasedirs "$TAG"
	: > "$TAG"
	test -f "$INFILE" || die "Cannot find patch file \"$INFILE\"!"
	mkbasedirs "$STRIPPED"
	exec 7> "$STRIPPED"; OUT7=Y
	SEARCH=---
	ANY=
	while IFS= read -r LINE
	do
		case $LINE in
			"Guards-Tag: Line = "[1-9]*)
				if parse_guards_tag "$LINE"
				then
					LINE=${REPLY%%:*}
					COND=${REPLY#*:}
					system printf '%06u' "$LINE"
					LINE=$OUTBASE/$REPLY
					mkbasedirs "$LINE"
					println "$COND" >> "$LINE"
					ITAGS=`expr $ITAGS + 1`
					ANY=Y
					continue
				fi
				;;
			"--- "*) test x$SEARCH = x--- && SEARCH=+++;;
			"+++ "*) test x$SEARCH = x+++ && SEARCH="@@";;
			"@@ "*)
				test x$SEARCH = x"@@" && {
					println "$LINE" >& 7
					run cat >& 7
					break
				}
				;;
			*) SEARCH=---;;
		esac
		println "$LINE" >& 7
	done < "$INFILE"
	close7
	# Remove stripped file if nothing has actually been stripped from it.
	if test -n "$ANY"
	then
		IFILES=`expr $IFILES + 1`
	else
		run rm "$STRIPPED"
	fi
}


print_first_file() {
	run ls -1 -- "$1" | run head -n1
}


init_reconstructed() {
	CONDS=; COND_PATCHES=; CLINE=$1
}


flush_reconstructed() {
	test -z "$COND_PATCHES" && return
	println "$CONDS${CONDS:+ }$COND_PATCHES" >& 7
}


reconstruct() {
	local PATCH
	local REPLY OUTBASE NCLINE GUARDSLINEFILE COND
	PATCH=$1
	OUTBASE=$TD/p/$PATCH
	NCLINE=
	if test -e "$OUTBASE"
	then
		system print_first_file "$OUTBASE"; NCLINE=$REPLY
	fi
	test -z "$NCLINE" && return
	if test x"$NCLINE" != x"$CLINE"
	then
		flush_reconstructed
		init_reconstructed "$NCLINE"
	fi
	qin "$PATCH"
	COND_PATCHES=$COND_PATCHES${COND_PATCHES:+ }$REPLY
	GUARDSLINEFILE=$OUTBASE/$CLINE
	while IFS= read -r COND
	do
		qin "$COND"
		CONDS=$CONDS${CONDS:+ }$REPLY
	done < "$GUARDSLINEFILE"
	run rm "$GUARDSLINEFILE"
}


enum_modified() {
	(
		run cd "$TD"/s
		run find -type f | run sed -e 's,^\./,,'
	) || exit
}


derive_names() {
	ORIG=$PATCHES_DIR/$PATCH
	if test -n "$WRITE_NEW_PATCHES"
	then
		TARGET=$ORIG.new
	else
		TARGET=$ORIG.orig
	fi
}


DEBUG=
DEFAULT_OUTPUT_NAME=series.guards
OUTPUT_FILE=
WRITE_DEFAULT_OUTPUT_FILE=
DELETE_TAGS=
OVERWRITE_OLD_BACKUPS=
WRITE_NEW_PATCHES=
KEEP_BACKUPS=
VERBOSE=
while getopts go:dvNOKhV OPT
do
	case $OPT in
		o) OUTPUT_FILE=$OPTARG;;
		g) WRITE_DEFAULT_OUTPUT_FILE=Y;;
		d) DELETE_TAGS=Y;;
		O) OVERWRITE_OLD_BACKUPS=Y;;
		K) KEEP_BACKUPS=Y;;
		N) WRITE_NEW_PATCHES=Y;;
		v) VERBOSE=Y;;
		h) show_help; exit;;
		V) show_version; exit;;
		*) false; exit;;
	esac
done
shift `expr $OPTIND - 1`
if test $# != 0
then
	PATCHES_DIR=$1;	shift
elif test -n "$QUILT_PATCHES"
then
	PATCHES_DIR=$QUILT_PATCHES
elif test -d patches
then
	PATCHES_DIR=patches
else
	PATCHES_DIR=.
fi
test $# = 0 || die "Unexpected arguments: $*!"
PATCHES_DIR=${PATCHES_DIR%%/}
run test -n "$PATCHES_DIR" # "/" not supported as patches directory.
SERIES=$PATCHES_DIR/series
test -f "$SERIES" || die "Could not locate series file \"$SERIES\"!"
test -n "$WRITE_DEFAULT_OUTPUT_FILE" && {
	OUTPUT_FILE=$PATCHES_DIR/$DEFAULT_OUTPUT_NAME
}
test x"${OUTPUT_FILE##*/}" != x"series" || {
	die "The output file must not have the basename 'series'!"
}
test -n "$OUTPUT_FILE" && overwrite_check "$OUTPUT_FILE"
OUT7=
# Create temporary working directories.
while :
do
	if test -n "$DEBUG"
	then
		TD=`pwd`/wd
		test -d "$TD" && rm -r --one-file-system "$TD"
		mkdir -m700 "$TD" && break
	else
		system mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXXXXXX"; TD=$REPLY
		break
	fi
done
run mkdir "$TD"/p
run mkdir "$TD"/s
trap cleanup 0
# Extract tags and create stripped copies.
IFILES=0; ITAGS=0
{
	while IFS= read -r PATCH
	do
		extract "$PATCH"
	done
} < "$SERIES"
# Reconstruct.
if test -n "$OUTPUT_FILE"
then
	exec 7> "$OUTPUT_FILE"
else
	exec 7>& 1
fi
OUT7=Y
{
	init_reconstructed
	while IFS= read -r PATCH
	do
		reconstruct "$PATCH"
	done
	flush_reconstructed
} < "$SERIES"
close7
# Check for inconsistencies.
{
	(
		run cd "$TD"/p
		run find -type f | run sed -e '
			s,^\./,,
			s,^\(.*\)/\([0-9]*\)$,\2:\1,
		'
	) || exit
} | LC_ALL=C run sort -t: -k1,1 -k2 | {
	exec 7>& 2
	OUT7=Y
	init_reconstructed
	ANY=
	while IFS= read -r PATCH
	do
		PATCH=${PATCH#*:}
		test -z "$ANY" && {
			wr <<- .
			WARNING: The following additional "guards"
			configuration entries extracted from
			"Guards-Tag:"-lines are inconsistent with "$SERIES"
			and could therefore not be integrated into the
			reconstructed "guards" configuration file (these
			warning messages are being written to the standard
			output channel only):
.
			echo
			ANY=Y
		} >& 7
		reconstruct "$PATCH"
	done
	flush_reconstructed
	if
		test -n "$DELETE_TAGS" && test -n "$OUTPUT_FILE" \
		&& test -n "$ANY"
	then
		echo
		wr <<- .
		Aborting: Combined tag extraction and tag removal has been
		requested, but inconsistencies have been detected during tag
		extraction. Tag removal will not be performed as a security
		precaution. Re-run $APP for tag removal only in order to
		ignore these warnings and remove the tags anyway.
.
	else
		ANY=
	fi
	close7
	test -z "$ANY"
} || exit
test -z "$OUTPUT_FILE" && echo >& 2
wr <<- EOF >& 2
Exctracted $ITAGS 'Guards-Tag:'-lines from a total of $IFILES patch file
headers.
EOF
test -z "$DELETE_TAGS" && exit
# Strip tags.
enum_modified | {
	while IFS= read -r PATCH
	do
		derive_names
		run test -f "$ORIG"
		overwrite_check "$TARGET"
	done
	true
} || exit
enum_modified | {
	while IFS= read -r PATCH
	do
		derive_names
		if test -z "$WRITE_NEW_PATCHES"
		then
			run mv -- "$ORIG" "$TARGET"
			OUT=$ORIG
		else
			OUT=$TARGET
		fi
		test -n "$VERBOSE" && echo "Writing stripped \"$OUT\"."
		run cat -- "$TD"/s/"$PATCH" > "$OUT"
		if test -z "$KEEP_BACKUPS" && test -z "$WRITE_NEW_PATCHES"
		then
			run rm "$TARGET"
		fi
	done
}
wr <<- EOF >& 2
Wrote $IFILES stripped patch files.
EOF

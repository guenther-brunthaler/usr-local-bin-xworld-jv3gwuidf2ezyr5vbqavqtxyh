#! /bin/sh
show_version() {
	wrL <<-.
	$APP version 10.185

	(c) 2010 by Guenther Brunthaler.
	Distribution is permitted under the terms of the GPLv3.
.
}


show_help() {
	{
	wr <<-.
	$APP - Generate BASE-35 encoded DCE UUIDs
	
	$APP generates time-based DCE UUIDs (UUIDs are also known as GUIDs in
	the Microsoft world) and prints them in BASE-35 encoding to standard
	output.
	
	In addition, $APP can be used to convert existing UUIDs between the
	BASE-35 and classical hexadecimal formats.

	
	Command line options accepted by $APP:
		
	--: Stop parsing for command line options. Any arguments following
	this option will be interpreted as normal arguments, even if they
	start with "-" or "--".

	--random, --randomly, --random-based, -r: Generate UUIDs based on
	random numbers. This is the default because of privacy considerations.
	However, there is a very small chance for duplicate UUIDs generated
	with this method.

	--time, --time-based, -t: Generate UUIDs based on the current date and
	time as well as the MAC address of the first network card. See the
	discussion about --time-based below.
	
	--convert <symbol>, -c <symbol>: Convert <symbol> into the opposite
	UUID format (BASE-35 or hex-based), depending on what format <symbol>
	is using right now. <symbol> can either be a pure UUID representation,
	or a symbolic name which contains a valid UUID as part of its name.
	The UUID is extracted from <symbol> by searching for the last matching
	substring which looks like an UUID. For the BASE-35 representation,
	this means a string of 25 contiguous characters from the BASE-35
	alphabet. For hex-representation, this means 32 hex-characters which
	must be continguous except that dashes or underscores are optionally
	allowed at the positions where the usual hex-format inserts them. In
	both cases, the matching UUID substring must not be preceded or
	followed by either a letter or a digit in order to considert for
	matching at all. Both upper or lower case characters are allowed
	within the <symbol> substring which represents a UUID, but no mixture
	of upper and lower case characters.
	
	--multiformat-output, -m: Display the output in multiple formatting
	variants.

	--help, -h, --usage: Display this help.

	--version, -V: Show version information.

	"Switch clustering" for short-options (single-dash options) is
	supported. For instance, when specifying two separate options "-h" and
	"-V", the combined option argument "-hV" means exactly the same thing.
	
	
	What is a BASE-35 UUID?
	
	
	UUIDs are 128-bit numbers generated in a way to minimize the chance
	that the same UUID will ever be generated again.
	
	UUIDs are among the best choices for automatically-generated
	identifiers which must be globally unique.
	
	UUIDs are normally generated by the "uuidgen" tool and will be
	generated in a hexadecimal representation.
	
	However, the hexadecimal representation consists of a minimum of 32
	characters which might be too long for some purposes.
	
	As a solution, $APP can be used instead of "uuidgen" which will encode
	a UUID in 25 instead of 32 characters.
	
	$APP uses an 35-character alphabet consisting only of digits and most
	lower-case letters.
	
	The alphabet size of 35 has been chosen because it is the tightest
	possible encoding without resorting to the inclusion of mixed-case
	characters or symbol characters in the alphabet.
	
	The alphabet used is also safe to be used as part of filenames and
	does not require case-sensitive filesystem semantics.
	
	Execute the following shell command in order to display the alphabet:

	$ perl -e "print join('', '0' .. '9', 'a' .. 'n', 'p' .. 'z'), qq'\n'"

	In short: All decimal digits and letters have been used except for the
	letter 'o' ("oh").
	
	
	DISCUSSION - When to choose --time-based over --randomly

	As explained in the option summary above, --randomly is the default
	setting for privacy considerations.
	
	However, only time-based UUIDs are guaranteed to be really unique
	throughout all space and time.
	
	The problem with random-based UUIDs is that the same random number can
	be generated multiple times. The chance for this is very small because
	UUIDs are made of a rather large number of bits, but it is not zero.
	
	Time-based UUIDs, on the other hand, are not primarily based on random
	numbers, but rather on the current date and time plus the MAC address
	of the first ethernet card of the local machine.
	
	The inclusion of date/time guarantees that no duplicates of this UUID
	can be generated at some later time. The inclusion of the MAC address
	guarantees that no other system can generate the same UUID even if
	UUIDs are generated at the same time by different computer systems
	throughout the world. This is because MAC-addresses as assigned by
	network card manufacturers are always unique.
	
	All UUID-generating instances on the same computer system also work
	together in order to ensure the same UUID is never returned twice on
	this system, even if multiple processes request many UUIDs at the same
	time. For this purpose, UUIDs also include a local sequence number
	field which will be incremented in the case more UUIDs are requested
	than the timer resolution could resolve. In order to minimize the
	chance for collisions even further, that sequence number field is
	initialized with a random number each time the UUID generating
	processes are starting up.
	
	So, in theory, time-based UUIDs are always better. They also allow to
	determine date and time when they have been generated.
	
	However, in practice, random-based UUIDs might be better suited
	depending on the situation.
	
	First and foremost, random-based UUIDs do not contain a MAC address.
	
	If your system does not have an ethernet card at all, this is a better
	choice because without a MAC there is no uniqueness-guarantee anyway.
	
	Also note that only MACs of *physical* ethernet cards can be guarateed
	to be unique. If your applications are running within a virtual
	machine that has a virtual ethernet card, the MAC will be assigned by
	software. Depending on how the MAC is assigned by the hypervisor, this
	might or might not guarantee uniqueness.
	
	But even if your box has a physical ethernet card there might a
	problem in the future: MAC-addresses as used in DCE UUIDs are 48-Bit
	numbers, but only 24 bits of it are meant to be used as a serial
	number. The remaining bits identifiy the network card manufacturer and
	some configuration information.
	
	In any case, some future day will come when the last available MAC
	globally-unique MAC has been assigned, and then the MAC namespace will
	be depleted.
	
	Random-based UUIDs can still be generated on this and later days.
	
	Another problem is the MAC itself: All time-based UUIDs from the same
	machine will always contain the same MAC.
	
	This allows all time-based UUIDs generated on the same machine to be
	traced back to that machine. There are cases when this is even
	considered an advantage, but there are other scenarios when this will
	rather be considered an undesired leaking of system-private
	information.
	
	For instance, if two UUIDs with the same MAC are encountered, it is
	highly likely that both UUIDs have been generated on the same computer
	system. Depending on the nature of your application, you might not
	want to provide this information.
	
	So, feel free to use the -t option with $APP for minimizing the chance
	of collisions - but always consider the caveats discussed above!

.
	show_version
	} | less -e
}


die() {
	printf "ERROR: %s\n" "$*" >& 2
	false; exit
}


run() {
	"$@" && return
	die "Could not execute >>>$*<<< return code ${?}!"
}


system() {
	REPLY=`run "$@"` || exit
}


wr() {
	if
		test $# -gt 0
	then
		printf '%s\n' "$*" | wr
	else
		fmt -w `tput cols`
	fi
}


wrL() {
	local LINE
	while
		IFS= read -r LINE
	do
		printf "%s\n" "$LINE" | wr
	done
}


warn() {
	printf "Warning: %s\n" "$*" | wr >& 2
}


foldcase() {
	LC_ALL=C run awk '{print to'$1'($0)}'
}


secho() {
	run printf '%s\n' "$*"
}


strip_sep() {
	secho "$1" | run tr -d -- -_
}


uuid2upperhex() {
	strip_sep "$*" | foldcase upper
}


hex2base35_helper() {
	system uuid2upperhex "$1"
	echo "obase= 35; ibase= 16; $REPLY" | run bc | while IFS= read -r REPLY
	do
		run printf '%s' "$REPLY"
	done | run tr -d '\\ ' | LC_ALL=C run awk '{
		al= "0123456789abcdefghijklmnpqrstuvwxyz"
		out= ""; b35= $0
		while (length(b35) != 50) b35= "0" b35
		for (i= 1; i <= 49; i+= 2) {
			dig= substr(b35, i, 2)
			if (dig < 0 || dig >= 35) {
				print "bad digit " dig > "/dev/stderr"
				exit 1
			}
			out= out substr(al, dig + 1, 1)
		}
		print out
	}'
}


hex2base35() {
	local REPLY
	system hex2base35_helper "$1"
	secho "$REPLY"
	test -z "$2" && return
	system toupper "$REPLY"
	secho "$REPLY"
}


sed_s() {
	local REPSUB STR RE S
	REPSUB=$1; shift; STR=$1; shift
	for S
	do
		RE=$RE$S
	done
	secho "$STR" | run sed -e "s/$RE/\\$REPSUB/;t;d"
}


parse_base35_helper() {
	system sed_s 2 "$1" \
		'\(^\|.*[^'$2'0-9]\)' \
		'\(['$3'0-9]\{25\}\)' \
		'\($\|[^'$2'0-9].*\)'
	test -n "$REPLY"
}


parse_base35() {
	parse_base35_helper "$1" a-z a-np-z \
	|| parse_base35_helper "$1" A-Z A-NP-Z
}


parse_uuid_helper() {
	system sed_s 2 "$1" \
		'\(^\|.*[^'$2'0-9]\)' '\(' \
		'['$3'0-9]\{8\}' '[-_]\?' \
		'['$3'0-9]\{4\}' '[-_]\?' \
		'['$3'0-9]\{4\}' '[-_]\?' \
		'['$3'0-9]\{4\}' '[-_]\?' \
		'['$3'0-9]\{12\}' \
		'\)' '\($\|[^'$2'0-9].*\)'
	test -n "$REPLY"
}


parse_uuid() {
	parse_uuid_helper "$1" a-z a-f \
	|| parse_uuid_helper "$1" A-Z A-F
}


reformat_hex() {
	strip_sep "$1" | foldcase lower
}


tolower() {
	secho "$1" | foldcase lower
}


toupper() {
	secho "$1" | foldcase upper
}


base35tohex_helper() {
	secho "$1" | LC_ALL=C run awk '{
		al= "0123456789abcdefghijklmnpqrstuvwxyz"
		for (i= 1; i <= length(al); ++i) {
			lu[substr(al, i, 1)]= i - 1
		}
		print("v= 0")
		for (i= 1; i <= length($0); ++i) {
			d= lu[substr($0, i, 1)]
			if (d < 0 || d >= 35) {
				print "bad digit " d > "/dev/stderr"
				exit 1
			}
			print("v= v * 35 + " d)
		}
		print("obase= 16; v")
		
	}' | run bc | foldcase lower
}


uuid_sep_helper_2() {
	secho "$U" | cut -c$F-$T
}


uuid_sep_helper() {
	system expr $F + $1; N=$REPLY
	system expr $N - 1; T=$REPLY
	system uuid_sep_helper_2
	F=$N
}


uuid_sep() {
	local U L1 W2 W3 W4 B5 F T N
	system strip_sep "$1"; U=$REPLY
	F=1
	uuid_sep_helper 8; L1=$REPLY
	uuid_sep_helper 4; W2=$REPLY
	uuid_sep_helper 4; W3=$REPLY
	uuid_sep_helper 4; W4=$REPLY
	uuid_sep_helper 12; B5=$REPLY
	REPLY="$L1$2$W2$2$W3$2$W4$2$B5"
}


prlen() {
	run printf '%s' "$1" | run wc -c
}


hexvariants() {
	local REPLY
	secho "$1"
	uuid_sep "$1" _
	secho "$REPLY"
	uuid_sep "$1" -
	secho "$REPLY"
	secho "{$REPLY}"
}


base35tohex() {
	local REPLY U
	system tolower "$1"
	system base35tohex_helper "$REPLY"; U=$REPLY
	while :
	do
		system prlen "$U"
		test $REPLY = 32 && break
		U=0$U
	done
	if test -n "$2"
	then
		hexvariants "$U"
		system toupper "$U"; U=$REPLY
		hexvariants "$U"
	else
		uuid_sep "$U" -
		secho "$REPLY"
	fi
}


APP=${0##*/}
GENOPT=-r
CONVERT=
MFMT=
COPTS=
while
	:
do
	if
		test -z "$COPTS"
	then
		case "$1" in
			-?*) COPTS="$1"; shift;;
			*) break;;
		esac
	fi
	if
		test "${COPTS#--}" = "$COPTS"
	then
		TAIL="${COPTS#-?}"; # Switch clustering.
		COPT="${COPTS%$TAIL}"; COPTS="${TAIL:+-}$TAIL"
	else
		COPT="$COPTS"; COPTS=
	fi
	# Any arguments are at $1 and onwards; must be shifted off.
	case "$COPT" in
		--) break;; # Must be first!
		--time | --time-based | -t) GENOPT=-t;;
		--random | --randomly | --random-based | -r) GENOPT=-r;;
		--convert | -c) CONVERT=$1; shift;;
		--multiformat-output | -m) MFMT=Y;;
		--help | -h | --usage) show_help; exit;;
		--version | -V) show_version; exit;;
		*) die "Unknown option '$COPT'!";; # Must be last!
	esac
done
test $# = 0 || die "Unexpected arguments >>>$*<<<!"
if test -n "$CONVERT"
then
	if parse_uuid "$CONVERT"
	then
		system reformat_hex "$REPLY"
		hex2base35 "$REPLY" "$MFMT"
	elif parse_base35 "$CONVERT"
	then
		base35tohex "$REPLY" "$MFMT"
	else
		die "There is no UUID in either encoding within '$CONVERT'!"
	fi
else
	system uuidgen $GENOPT
	hex2base35 "$REPLY" "$MFMT"
fi

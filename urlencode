#! /bin/sh
# URL-encodes any number of string arguments. Reads the strings from standard
# input if not arguments are provided. This is a transactional utility: Either
# all arguments will have been converted successfully, or none will be output
# if any of the conversions should fail.
#
# If option -p is specified, all strings must be absolute or relative
# pathnames of existing filesystem objects and will be converted to absolute
# 'file://'-URLs. "." and ".." will be resolved before conversion. The
# conversion will fail if any "." or ".." components remain in the pathnames
# because they could not be resolved.
#
# Version 2021.32
#
# Copyright (c) 2012-2021 Guenther Brunthaler. All rights reserved.
#
# This script is free software.
# Distribution is permitted under the terms of the GPLv3.

keep='-A-Za-z0-9/_.~'

set -e
cleanup() {
	rc=$?
	test "$TF" && rm -- "$TF"
	test $rc = 0 || echo "\"$0\" failed!" >& 2
}
TF=
trap cleanup 0
trap 'exit $?' INT QUIT TERM HUP

paths=false
while getopts p opt
do
	case $opt in
		p) paths=true;;
		*) false || exit
	esac
done
shift `expr $OPTIND - 1 || :`

println() {
	printf '%s\n' "$*"
}

cleanabspath() {
	sed -f /dev/fd/5 5<<- ===
		s|$|/|; s|/\{2,\}|/|g
		:1
			s|/[.]/|/|g
		t 1
		:2
			s|/[^/]\{1,\}/[.][.]/|/|g
		t 2
		s|.*/[.]\{1,2\}/.*||
		s|\(/.*\)/$|\1|
===
}

# Uses $cwd if $paths == true.
# Trashes: $n.
prepare() {
	n=$1
	case $paths in
		true)
			if
				test ! -e "$n" && {
					n=`println "$n" | cleanabspath`
					test -z "$n" || test ! -e "$n"
				}
			then
				echo "Pathname '$1' does not exist!" >& 2
				false || exit
			fi
			case $n in
				/*) ;;
				*) n=$cwd/$n
			esac
			if
				n2=`println "$n" | cleanabspath`
				test "$n2" && test -e "$n2"
			then
				n=$n2
			elif
				n2=`readlink -f -- "$n" | cleanabspath`
			then
				n=$n2
			else
				echo "Cannot resolve pathname '$1'!" >& 2
				false || exit
			fi
	esac
	println "$n"
}

TF=`mktemp -- "${TMPDIR:-/tmp}/${0##*/}".XXXXXXXXXX`
case $paths in
	true) cwd=`pwd`
esac
case $# in
	0)
		while IFS= read -r n
		do
			prepare "$n"
		done
		;;
	*)
		for n
		do
			prepare "$n"
		done
esac > "$TF"

pct_enc() {
	tr -d '\n' | od -vt x1 | cut -d ' ' -f 2- | head -n -1 \
		| tr 'a-f ' 'A-F\n' | sed 's/../%&/g' | tr -d '\n'
	echo
}

rxm() {
	LC_COLLATE=C expr x"$1" : x"$2" || :
}

while IFS= read -r left
do
	out=
	while :
	do
		out=$out`rxm "$left" '\(['"$keep"']*\)'`
		left=`rxm "$left" '['"$keep"']*\(.*\)'`
		case $left in
			'') break
		esac
		out=$out`rxm "$left" '\([^'"$keep"']*\)' | pct_enc`
		left=`rxm "$left" '[^'"$keep"']*\(.*\)'`
		case $left in
			'') break
		esac
	done
	case $paths in
		true) out=file://$out
	esac
	printf '%s\n' "$out"
done < "$TF"

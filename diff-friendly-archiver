#! /bin/sh
# Archiver for minimizing "diff"s (including binary diffs) between directory
# trees. The generated archives will be rsync-friendly as well.
#
# It only retains what Git generally also retains when a file is put under
# version control: Its relative pathname, its contents, its executable bit,
# and symlinks. Everything else will be ignored, such as additional permission
# bits, ACLs, owner, etc. Hard links might be supported in a later version of
# the script, but are not supported yet.
#
# Suggested archive file extension: "*.dfa".
#
# When only text files are put into the archive, the archive itself will be a
# text file as well. No "binary" byte values are used in the (very
# minimalistic) archive metadata framing.
#
# Version 2021.69
# Copyright (c) 2021 Guenther Brunthaler. All rights reserved.
#
# This script is free software.
# Distribution is permitted under the terms of the GPLv3.

set -e
trap 'test $? = 0 || echo "\"$0\" failed!" >& 2' 0

verbose=
block_size=32768
mode=
chdir=
file=
stdin=false
strip=0
while getopts p:TvtB:f:C:cx opt
do
	case $opt in
		p) test "$OPTARG" -ge 0; strip=$OPTARG;;
		T) stdin=true;;
		t) mode=list;;
		v) verbose=yes;;
		f) test -d "`dirname -- "$OPTARG"`"; file=$OPTARG;;
		C) test -d "$OPTARG"; chdir=$OPTARG;;
		c) mode=create;;
		x) mode=extract;;
		B) test "$OPTARG" -ge 1; block_size=$OPTARG;;
		*) false || exit
	esac
done
shift `expr $OPTIND - 1 || :`

println() {
	printf '%s\n' "$*"
}

die() {
	println "$*" >& 2
	false || exit
}

# Emulate "head -c" which is not defined by POSIX.
passthrough_bytes() {
	b=$1
	if test $b -gt $block_size
	then
		q=`expr $b / $block_size`
		r=`expr $b % $block_size || :`
		# Verify that no numeric overflows occurred in 'expr'.
		expr $q \* $block_size + $r = $b >& 7
		dd bs=$block_size count=$q 2>& 7
		b=$r
	fi
	case $b in
		0) ;;
		*) dd bs=$b count=1 2>& 7
	esac
}

create() {
	case $# in
		0)
			case $stdin in
				true) ;;
				*) set .
			esac
			;;
		*)
			case $stdin in
				false) ;;
				*)
					die "If -T is used, no non-option" \
						"arguments are supported!"
			esac
			i=$#
			while test $i != 0
			do
				if test ! -L "$1"
				then
					test -e "$1" \
					|| die "'$1' does not exist!"
				fi
				case $1 in
					-*) set -- "$@" ./"$1";;
					*) set -- "$@" "$1"
				esac
				shift
				i=`expr $i - 1 || :`
			done
	esac
	case $file in
		'') ;;
		*) exec > "$file"
	esac
	case $chdir in
		'') ;;
		*) cd -- "$chdir"
	esac
	case $stdin in
		true)
			while IFS= read -r f
			do
				if test ! -L "$f"
				then
					test -e "$f" \
					|| die "'$f' does not exist!"
					test -d "$f" \
					&& die "'$f': directories" \
						"are forbidden!"
				fi
				println "$f"
			done
			;;
		*) find "$@" ! -path . ! -type d
	esac \
	| sed 's|^[.]/||' \
	| LC_COLLATE=C sort \
	| while IFS= read -r f
	do
		case $f in
			/*) die "'$f': absolute paths are forbidden!"
		esac
		set -- `ls -og -- "$f" | cut -d ' ' -f 1,3`
		sf=$f
		case $strip in
			0) ;;
			*)
				i=$strip
				while test $i != 0
				do
					sf0=${sf#*/}
					case $sf0 in
						"$sf")
							die "Cannot strip $i" \
							"additional path" \
							"prefixes from '$sf'!"
					esac
					sf=$sf0
					i=`expr $i - 1 || :`
				done
		esac
		case $1 in
			-??x*)
				echo "X $2 $sf"
				cat < "$f"
				;;
			-*)
				echo "F $2 $sf"
				cat < "$f"
				;;
			l*)
				echo "L $2 $sf"
				readlink -- "$f" | passthrough_bytes $2
				;;
			*)
				die "Unsupported FSO type for '$f'!"
		esac
	done
}

extract() {
	test $# = 0
	case $file in
		'') ;;
		*) exec < "$file"
	esac
	case $chdir in
		'') ;;
		*) cd -- "$chdir"
	esac
	while IFS=' ' read -r t sz f
	do
		d=${f%/*}
		case $d in
			"$f") ;;
			*) mkdir -p -- "$d"
		esac
		case $t in
			F | X)
				passthrough_bytes $sz > "$f"
				case $t in
					X) chmod +x -- "$f"
				esac
				;;
			L) ln -sn -- "`passthrough_bytes $sz`" "$f";;
			*)
				die "Unsupported type '$t' in entry '$f'!"
		esac
	done
}

list() {
	test $# = 0
	case $file in
		'') ;;
		*) exec < "$file"
	esac
	while IFS=' ' read -r t sz f
	do
		case $verbose in
			'') printf '%s%s\n' "$f";;
			*) echo "$t $sz $f"
		esac
		passthrough_bytes $sz >& 7
	done
}

test "$mode"
$mode ${1+"$@"} 7> /dev/null

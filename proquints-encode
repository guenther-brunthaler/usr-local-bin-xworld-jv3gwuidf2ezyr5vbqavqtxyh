#! /bin/sh

# Convert binary standard input to Pronouncable Quintuplets ("proquints").
# Standard input is read in units of 16 bits, most significant octet first
# ("big endian" byte order).
#
# Version 2025.114
# Copyright (c) 2025 Guenther Brunthaler. All rights reserved.
#
# This script is free software.
# Distribution is permitted under the terms of the GPLv3.

od -vt o1 | awk -f /dev/fd/5 5<< 'EOF'

# Globals: i, o2b[], cn[], vw[], inbuf, nonfirst.

BEGIN {
	mk_o2b()
	al2arr(cn, "bdfghjklmnprstvz")
	al2arr(vw, "aiou");
}

{ for (i = 2; i <= NF; ++i) append($i) }

END {
	if (length(inbuf)) {
		print "Input size is not a multiple of 16 bits!" \
			> "/dev/stderr"
		exit system("false")
	}
	if (nonfirst) print ""
}

function mk_o2b(    octdigit) {
	for (octdigit = 8; octdigit--; ) {
		o2b[octdigit] = v2b(octdigit, 3, 4)
	}
}

function v2b(value, bits, msb    , binary, bit) {
	# if (msb != 2 ^ (bits - 1)) exit 100
	while (bits--) {
		if (bit = value >= msb) value -= msb
		binary = binary bit
		value += value
	}
	return binary
}

function al2arr(array, alphabet    , n, i, msb, bits) {
	n = length(alphabet)
	for (bits = msb = 1; ; msb = i) {
		i = msb + msb
		if (i >= n) break
		++bits
	}
	for (i = 1; i <= n; ++i) {
		array[v2b(i - 1, bits, msb)] = substr(alphabet, i, 1)
	}
}

function append(octal    , ocnt, i, nc, o, isvw, bix) {
	for (i = 1; i <= 3; ++i) {
		nc = o2b[substr(octal, i, 1)]
		if (i == 1) nc = substr(nc, 2)
		inbuf = inbuf nc
		if (length(inbuf) >= 16) {
			if (nonfirst) {
				o = "-"
			} else {
				o = ""; nonfirst = 1
			}
			isvw = 0; bix = 1
			for (ocnt = 5; ocnt--; ) {
				if (isvw) {
					o = o vw[substr(inbuf, bix, 2)]
					bix += 2; isvw = 0
				} else {
					o = o cn[substr(inbuf, bix, 4)]
					bix += 4; isvw = 1
				}
			}
			inbuf = substr(inbuf, bix)
			printf "%s", o
		}
	}
}

EOF

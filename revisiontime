#! /bin/sh
show_version() {
	cat <<- .
	$APP version 13.85

	(c) 2010 - 2013 by Guenther Brunthaler.
	Distribution is permitted under the terms of the GPLv3.
.
}


show_help() {
	cat <<- .
	$APP - synthesize a version number from the current date/time
	
	Usage: $APP [ options ]
	
	$APP displays the current date/time as a "version number", i. e.
	as a sequence of integer number components separated by dots (".").

	First component: 4-digit year minus 2000.
	
	Second component: Day within year ("cal -j").
	
	Third component (with option '-3'): Time of day 1 - 999.
	
	Third component (with option '-l'): Missing or integer sequence
	number starting with 1.

	Last component (with option '-s'): Integer sequence number starting
	with 1.
	
	Date / time is always interpreted as UTC only!
	This will create revision numbers that can be globally compared
	without being affected by the local time zone setting.

	Options:

	-3: Display a three-component number rather than a two-component one.
	-l <lastrev>: Display a two-compoment unless it would be the same as
	    <lastrev>. In this case, outputs a 3-component number where the
	    last component is the 3rd component of <lastrev> incremented by 1.
	    If <lastrev> does not have a 3rd component, assumes it to be 0.
	-s <seqpred>: Re-use an existing version number <seqpred> and only
	    increment its last component if it is an integer. Otherwise, just
	    append "-1" to <seqpred> if it was not an empty string, or use "1"
	    as the new revision number if it was an empty string.
	-h: Show this help.
	-V: Show only the version information.

	The revision numbers calculated by $APP will only have day granularity
	if neither -3 nor -l nor -s options are specified. This should be
	enough if updates of the versioned entity are not too frequent.
	
	For allowing sub-day granularity, the -l, -s and -3 options can be
	used in the following scenarios:
	
	"-l" allows to generate 2-component date-based revision numbers by
	default. But if more than 1 revision is generated for the same day, a
	third component is appended which is a simple integer counter.

	"-s" generates "classical" sequential revision numbers. It only cares
	about the last component of an existing revision number and increments
	it by 1.
	
	"-3" generates a third component only from the time of day. No
	knowledge of the last generated revision number is required.

	The options -l and -s can only be used if the last emitted revision
	number is known. Those options are therefore restricted to scenarios
	where a central authority issues the revision numbers, or where there
	is at least some protocol in place which allows the team members to
	co-ordinate emission of new revision numbers. Both options are
	therefore not well suited for truly distributed development.
	
	The -3 option is the choice for distributed teams where team
	members can release new versions at any time, and does not require
	any co-ordination between team members.
	
	I recommend using option -l where possible.
	
	It has the advantage that the version number is basically a date as
	for the 2-component version numbers generated by $APP by default.
	
	But it still allows sub-day granularity by adding an integer counter
	as a third component, where "<year>-<day>" is interpreted the same as
	"<year>-<day>-0". Therefore, a revision "13.37" means the same as
	"13.37.0", and thus the next revision (for the same day only) will be
	"13.37.1". $APP would therefore generate the following sequence of
	revision numbers for that day: "13.37", "13.37.1", "13.37.2" etc.

	Actually, how "-l" really works is as follows: It first generates a
	2-component date-bases revision number. Then it compares this number
	to the provided last revision number. If the specified last revision
	number has different leading component numbers than the newly
	generated revision number, then a new day has come and the new
	2-component number is used directly. Otherwise, another revision for
	the current day shall be generated, and "-l" adds a third compontent
	".1", or increments an existing third component if one is already
	present.

	The "-s" option is used	to generate "classical" revision numbers: It
	checks wheter the end of the specified old revision number looks like
	the last component of a revision number, and if so, increments it.
	
	If the old revision is an empty string, generates "1" as the new revision.
	
	If the old revision number is a non-empty string but its end does not
	look like the last component of a revision number, it is assumed there
	is no revision number there yet and "-1" is addes to the string in
	order to create the first numbered revision.
	
	To clarify the expression "looks like the last component of a revision
	number": If the old revision ends with a substring that can be
	interpreted as an integer, it is assumed to be the last component of a
	revision number. It does not matter which version component
	separators, if any, precede the integer suffix.
	
	Here are some examples which old revision numbers lead to which new
	revision numbers generated by "-s": "13.37" -> "13.38", "test-62" ->
	"test-63", "1.0.9" -> "1.0.10", "heck" -> "heck-1", "42" -> "43", "v5"
	-> "v6", "r246" -> "r247", "" -> "1", "mytools-alpha-7.2.3.9" ->
	"mytools-alpha-7.2.3.10".
	
	As one can see, it does not matter whether the old "revision number"
	is actually a full package name whith a trailing version number - it
	works as well.

	The -3 option will typically not be used if version numbers are
	assigned by a single person only (or by a central authority). In such
	cases it will be much easier to just increment an integer as the third
	component.
	
	For instance, let's say $APP returned a two-component revision number
	of 10.204 for the first revision on that day. This number is then used
	directly for that first revision. When another revision number is
	required, the developer notices that $APP still generates 10.204 and
	therefore adds a third component, making it 10.204.1. The next
	revision on that day will be 10.204.2, 10.204.3 and so on.
	
	But things are different when a team of developers is working on a
	project in a fully distributed fashion, and multiple team members are
	entitled to release new versions at any time with no permanent
	synchronization between team members.
	
	In this case, it is best to *not* use incremental integers as the
	third component, but rather the -3 option of $APP.
	
	This will generate the third component based on the current universal
	time, where the third component increments approximately in two-minute
	intervals.
	
	This means there is only a very small chance that two team members
	release a new version with the same revision number even without any
	further co-ordination than agreeing to use $APP to generate revision
	numbers.
	
	How is the third component calculated?
	
	First, the current UTC time is broken down into hours, minutes and
	seconds. Then this is converted into the number of seconds since
	midnight. In this calculation, it is assumed that a minute can have 62
	seconds (60 normal seconds plus up to 2 leap seconds).
	
	The resulting number is then mapped linearly into the range 1 to 999.
	(This means the third component will always be within the bounds of
	that range.)

.
	show_version
}




APP=${0##*/}
OREV=
THREE=
while getopts l:s:3hV OPT
do
	case $OPT in
		3) THREE=$OPT;;
		l | s) THREE=$OPT; OREV=$OPTARG;;
		h) show_help; exit;;
		V) show_version; exit;;
		*) false; exit;;
	esac
done
date -u '+%Y %j %H %M %S '$THREE' '$OREV | awk '{
	three= ""; r= $1 - 2000 "." $2 + 0
	if ($6 == "3") {
		three= "." int( \
			(($3 * 60 + $4) * 62 + $5) * (1000 - 1) \
			/ (24 * 60 * 62) \
			+ 1 \
		)
	} else if ($6 == "l" && index($7, r) == 1) {
		if ("x" r == "x" $7) three= ".1"
		else $6= "s"
	}
	if ($6 == "s") {
		if (match($7, "[0-9]+$")) {
			r= substr($7, 1, RSTART - 1)
			three= substr($7, RSTART) + 1
		} else {
			r= $7
			three= r == "" ? 1 : -1
		}
	}
	print r three
}'

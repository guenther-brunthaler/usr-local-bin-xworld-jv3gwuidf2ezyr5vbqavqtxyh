#! /bin/sh
usage() {
	cat << .
This is a simple script for installing and uninstalling user-built packages.

Pipe a file list to this running script in order to uninstall a previously
user-installed package.

Create the file list by installing the package into a staging directory first,
typically by

\$ ./configure --prefix=\$HOME
\$ make
\$ test -e staging && rm -r staging; mkdir staging
\$ make install DESTDIR=\`pwd\`/staging

Then change to the staging directory and run

\$ cd staging
\$ find -depth | tee /dev/stderr | gzip -9 > ~/var/lib/manually_installed/name_of_package.flist.gz

This is just an example; change the storage path and package name as you like.
The saved file contains the file list of the package for later uninstallation.

Finally, install the files from the staging dir into the live file system via

\$ rsync -pvrl ./\$HOME/ \$HOME/

In order to uninstall package 'name_of_package' at some later time:

\$ zcat ~/var/lib/manually_installed/name_of_package.flist.gz | ${0##*/}
\$ rm ~/var/lib/manually_installed/name_of_package.flist.gz

(c) 2013 by Guenther Brunthaler.
This script is free software.
Distribution is permitted under the terms of the GPLv3.
.
}


set -e
case $1 in
	-*) usage; exit
esac
trap "echo 'Failed!'" 0
cd /
while IFS= read -r LINE
do
	test x"$LINE" = x"." && continue
	test x"${LINE#./}" != x"$LINE" || {
		echo "All lines need to start with './'!" >& 2
		false; exit
	}
	if test -d "$LINE"
	then
		# It is possible that $LINE is a symlink to a directory. In
		# this case removal will always fail. But this is a good
		# thing, because such symlinks were most likely not created by
		# the installer and should be kept. Just think about a symlink
		# /lib64 -> /lib.
		rmdir -- "$LINE" || true
	elif test -e "$LINE"
	then
		rm -- "$LINE" || {
			echo "Could not delete '/$LINE'!" >& 2
			false
		}
	fi
done
trap - 0
echo "Uninstallation complete."

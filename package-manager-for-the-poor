#! /bin/sh
version() {
	cat << .
$APP version 13.44

(c) 2013 by Guenther Brunthaler.
This script is free software.
Distribution is permitted under the terms of the GPLv3.
.
}


usage() {
	cat << .
$APP - poor man's package management script

This is a simple script for installing and uninstalling user-built packages.

It depends on a minimal set of external commands and is intended to work even
in minimal system installations.

Usage: $APP <command> <arguments> ...

Commands:

-i: Install files from a package, from a directory, or from "make install".
-l: List files from an installed or uninstalled package or list packages.
-s: Search to which installed package a file/path belongs.
-v: Verify that package files are still the same as after installation.
-u: Uninstall a previously installed package.
-p: Create a package from directory tree contents or from a file list.
-h: Show this help.
-V: Show version information.

Options:
-d <directory>: Divert installation to <directory> instead of to "/".

Usage variants:
-i: Like "make install" but record for later uninstallation.
-i /path/to/staging/dir: Install from staging directory contents.
-i /path/to/staging/dir pkgname: Same but override package name.
-i /path/to/package/file: Install from package file.
-i /path/to/package/file pkgname: Same but override package name.
-l /path/to/package: List package contents.
-l pkgname: List contents of already-installed package.
-l: Display list of currently installed packages.
-v pkgname: Verify contents of the installed package.

*** Example: Install files after "./configure && make":

This does not require creating a package first. The package has to
be built already, such as by

\$ ./configure --prefix=\$HOME
\$ make

Now run

\$ $APP -i

This will automatically do a

\$ make install DESTDIR=\$STAGING_DIR

thus installing all files to be installed into a temporary staging directory
\$STAGING_DIR.

It will then create and save a file list for later uninstallation by using the
basename of the current directory as a the package name.

Finally, it will merge the contents of the staging directory into the live
file system, thus completing the installation. The temporary staging directory
will be removed after this.

*** Example: Install files from a staging directory:

In this case, all the files to be installed need to be copied to a staging
directory manually first. For instance:

\$ ./configure --prefix=\$HOME
\$ make
\$ test -e mypackage-1.0 && rm -rf mypackage-1.0
\$ mkdir mypackage-1.0
\$ make install DESTDIR=\`pwd\`/mypackage-1.0

The contents of the staging directory will be
copied to the root of the live file system recursively.

\$ $APP -i mypackage-1.0

The basename of the staging directory will be used as the package name.

\$ $APP -i /path/to/staging/directory package_name-1.0

This is the same, except that the package name is specified directly as an
additional argument. In this case, the basename of the staging directory has
no effect on the package name.

*** Example: Install files from a package:

A package is a simple archive containing the contents of a staging directory.
Installing from a package is quite similar to installing from a staging
directory, only that an archive file is specified instead of a directory.

\$ $APP -i /path/to/staging/directory package_name-1.0.tgz

In this case, the basename of the package file (minus the filename extension)
will be used as the package name. The package name is thus "package_name-1.0".

If the stripped filename extension has been preceded by ".tar", this will be
stripped as well:

\$ $APP -i /path/to/staging/directory package_name-1.0.tar.gz

The following file extensions are directly supported by this script:

.tar
.tar.bz2
.tar.gz
.tbz
.tgz

This means the script will automatically add the right option for tar when
unpacking.

Other extensions are supported as long as tar knows how to unpack such files
automatically without requiring specific options.

The recommended file extension/format for packages is ".tgz".

\$ $APP -i /path/to/staging/directory name-1.0.tgz name-1.0.alpha

will also install a package, but override the package name under which the
package will be recorded as being installed. This will record the name of the
installed package as "name-1.0.alpha" instead of "name-1.0".

*** Configuration file:

The script reads settings from the following configuration file:

$CONFIG_FILE

The location of that file can be changed by setting environment variable
XDG_CONFIG_HOME (which defaults to "\$HOME/.config").

*** The database of installed packages:

Information about all currently installed packages is stored in the following
directory:

$DATA_DIR

The location of that directory can be changed by setting environment variable
XDG_DATA_HOME (which defaults to "\$HOME/.local/share").
.
	echo; version
}


cleanup() {
	test -z "$OK" && echo 'Failed!' >& 2
	test -n "$TDIR" && release_tmp_dir
	test -n "$OK"
}


cmd_uninstall() {
	cd /
	while IFS= read -r LINE
	do
		test x"$LINE" = x"." && continue
		test x"${LINE#./}" != x"$LINE" || {
			echo "All lines need to start with './'!" >& 2
			false; exit
		}
		if test -d "$LINE"
		then
			# It is possible that $LINE is a symlink to a directory. In
			# this case removal will always fail. But this is a good
			# thing, because such symlinks were most likely not created by
			# the installer and should be kept. Just think about a symlink
			# /lib64 -> /lib.
			rmdir -- "$LINE" || true
		elif test -e "$LINE"
		then
			rm -- "$LINE" || {
				echo "Could not delete '/$LINE'!" >& 2
				false
			}
		fi
	done
	echo "Uninstallation complete." >& 2
}


die() {
	{
		echo "ERROR: $*"
		echo "Use -h for help."
	} >& 2
	OK=Y; false
}


# Ensures a directory exists by creating it recursively if necessary.
# Assumes set -e.
ensure_dir() {
	test -d "$1" && return
	ensure_dir "`dirname -- \"$1\"`"
	mkdir -m 700 -- "$1"
}


# Locate or migrate configuration file or data directory $2.
#
# $2 needs to have $UUID as part of its name. If $1 is -d then $2 is a
# directory. If $1 is -f then $2 is a file.
#
# Returns true if $2 exists or has been migrated successfully.
#
# Returns false if the caller should create $2. In this case, the parent
# directory of $2 will already exist.
locate_config() {
	test $1 "$2" && return
	test ! -e "$2"
	local d f found old
	d=`dirname -- "$2"`
	f=`basename -- "$2"`
	ensure_dir "$d"
	found=
	for old in "$d"/*$UUID*
	do
		if test $1 "$old"
		then
			mv -- "$old" "$2"
			found=Y
			break
		fi
	done
	! test -z "$found" # Avoid termination by set -e.
}


release_tmp_dir() {
	rm -rf -- "$TDIR" || :
	TDIR=
}


create_tmp_dir() {
	local t
	while :
	do
		t=`"$TEMPFILE"`
		rm -- "$t"
		mkdir -m 700 -- "$t" && break
		sleep 1
	done
	TDIR=$t
}


# Set FLIST to the file list name of the package $1.
# Returns true for success.
locate_flist() {
	local xt b
	if test x"${1%/*}" = x"$1"
	then
		b=$DATA_DIR/$1
		for xt in .gz .bz2 .xz .lzma .txt
		do
			FLIST=$b$xt
			test -f "$FLIST" && return
		done
	fi
	FLIST=
	! true
}


pack_best() {
	gzip -9 "$1"
}


# [ <option> ] VAR $cmd: Sets $VAR to path of executable $cmd.
# Without option: Return code indicates success.
# -i: Ignore failure; always report success.
# -f: Die if command could not be found.
# In all cases, $VAR is set to empty if command not found.
getcmd() {
	case $1 in
		-*) ;;
		*) set -- -- "$@"
	esac
	# There is a bug in bash's eval: It does not return the status of a
	# backquote substitution. Adding a redundant test to fix it.
	eval "$2=`which \"$3\" 2> /dev/null`; test $? = 0" && return
	eval "$2="
	test $1 = "-f" && die "Required utility '$3' is not installed!"
	! test $1 != "-i"
}


# <startdir> <callback> [ <targetpath> ]
dirwalk() {
	local s t
	s=${1%/}; t=${3%/}
	(
		cd "$1"
		find . ! -path . | cut -d/ -f2-
	) | while IFS= read -r e
	do
		"$2" "$s/$e" "$t/$e"
	done
}


pre_check() {
	if test -d "$1"
	then
		test -d "$2" && return
	elif test -f "$1"
	then
		:
	elif test ! -L "$1"
	then
		die "Unsupported file type in relative source path '$1'!"
	fi
	if test -e "$2"
	then
		die "Installation pre-check failed: '$2' already exists!"
	fi
}


merge_into() {
	test -e "$2" && return
	if test -L "$1"
	then
		local target
		target=`readlink "$1"`
		ln -s -- "$target" "$2"
	elif test -d "$1"
	then
		local mode
		mode=`stat -c %a -- "$1"`; test -n "$mode"
		mkdir -m "$mode" -- "$2"
	else
		test -f "$1"
		# Suppress messages that changing ownership failed.
		cp -p -- "$1" "$2" 2> /dev/null
	fi
}


# $@: obj-type, checksum-kind, path.
calcsum() {
	test $1 = dir && return
	case $1 in
		sym) readlink "$3";;
		file) cat "$3"
	esac | {
		test -n "$2" && printf 'k=%s c=' "$2"
		case $2 in
			md5) "$MD5SUM" -b -- | cut -d" " -f1;;
			cks) "$CKSUM" -- | tr " " ':'
		esac
	}
}


# $1: type, $2: path.
stat2() {
	case $1 in
		file) f="a=%a o=%u:%g m=%Y s=%s";;
		dir) f="a=%a o=%u:%g";;
		sym) f="s=%s";;
		*) false
	esac
	stat -c "$f" "$2"
}


# Set $n to directory entry type.
stat1() {
	if test -L "$1"
	then
		n=sym
	elif test -d "$1"
	then
		n=dir
	else
		test -f "$1"
		n=file
	fi
}


# Set $copt to the right tar compression option for archive $1.
get_copt() {
	case $1 in
		*.tgz | *.tar.gz) copt=-z;;
		*.tbz | *.tar.bz2) copt=-j;;
		*) copt=
	esac
}


# Print decompressed file list "$1".
dccat() {
	case $1 in
		*.gz) "$GZIP" -dc;;
		*.bz2) "$BZIP2" -dc;;
		*.xz) "$XZ" -dc;;
		*.lzma)
			if test -n "$LZMA"
			then
				"$LZMA" -dc
			else
				"$XZ" -dc
			fi
			;;
		*.txt) ;;
		*) die "Unsupported file extension of list file '$1'!"
	esac < "$1"
}


cmd_install() {
	local dir pkg
	case $# in
		0)
			dir=`pwd`
			test -n "$dir"; test -d "$dir"
			pkg=`basename "$dir"`; test -n "$pkg"
			create_tmp_dir
			make install DESTDIR="$TDIR"
			cmd_install "$TDIR" "$pkg"
			release_tmp_dir
			;;
		1)
			test -n "$1"
			if test -d "$1"
			then
				dir=`readlink -f "$1"`
				test -n "$dir"; test -d "$dir"
				pkg=`basename "$dir"`
			else
				test -f "$1"
				pkg=${1%.*}; pkg=${pkg%.tar}
			fi
			test -n "$pkg"
			cmd_install "$1" "$pkg"
			;;
		*)	test $# = 2
			pkg=$2; test -n "$pkg"
			if locate_flist "$pkg"
			then
				die "Package '$pkg' is already installed!"
			fi
			if test -f "$1"
			then
				local copt
				get_copt "$1"
				create_tmp_dir
				"$TAR" -x $copt -f "$1" -C "$TDIR"
				cmd_install "$TDIR" "$pkg"
				release_tmp_dir
			else
				test -d "$1"
				dirwalk "$1" pre_check "$ITARGET"
				local FLIST
				FLIST=$DATA_DIR/$pkg; test ! -e "$FLIST"
				(
					cd "$1"
					find . -depth ! -path . \
					| cut -d/ -f2-
				) | {
					pfx=${ITARGET%/}/
					while IFS= read -r p
					do
						printf 'p=%s%s\n' "$pfx" "$p"
					done
				} > "$FLIST"
				dirwalk "$1" merge_into "$ITARGET"
				local fln line p n x
				fln=$FLIST.update
				while IFS= read -r line
				do
					p=${line#p=}
					stat1 "$p"
					x=`stat2 "$n" "$p"`
					x="t=$n $x"
					n=`calcsum $n "$CHKDFLTYPE" "$p"`
					echo "$x${n:+ }$n $line"
				done < "$FLIST" > "$fln"
				rm -- "$FLIST"
				mv -- "$fln" "$FLIST"
				pack_best "$FLIST"
			fi
	esac
}


cmd_list() {
	case $# in
		0)
			echo "List of currently installed packages:" >& 2
			ls -- "$DATA_DIR" | while IFS= read pkg
			do
				f=$DATA_DIR/$pkg
				when=`date -r "$f" +"%Y-%m-%d %H:%M:%S"`
				printf '%s %s\n' "$when" "${pkg%.*}"
			done
			;;
		*)	test $# = 1
			if locate_flist "$1"
			then
				dccat "$FLIST" | sed -e 's,.*p=,,'
			elif test -f "$1"
			then
				local copt
				get_copt "$1"
				"$TAR" -t $copt -f "$1"
			else
				die "'$1' is neither an installed package" \
					"nor a package file!"
			fi
	esac
}


set -e
OK=
TDIR=
trap cleanup 0
UUID=7rttpq19eb58ybhqm18dktllt
APP=${0##*/}
getcmd -f TEMPFILE tempfile
getcmd -i GZIP gzip
getcmd -i BZIP2 bzip2
getcmd -i XZ xz
getcmd -i LZMA lzma
getcmd -f TAR tar
getcmd -i MD5SUM md5sum
getcmd -i CKSUM cksum
if test -n "$MD5SUM"
then
	CHKDFLTYPE=md5
elif test -n "$CKSUM"
then
	CHKDFLTYPE=cks
else
	CHKDFLTYPE=
fi
test -n "$HOME" && test -d "$HOME"
: ${XDG_DATA_HOME:=$HOME/.local/share} ${XDG_CONFIG_HOME:=$HOME/.config}
APP_=`printf '%s' "$APP" | tr -sc '[:alnum:]' _`
CONFIG_FILE=$XDG_CONFIG_HOME/${APP_}_$UUID.conf
DATA_DIR=$XDG_DATA_HOME/${APP_}_$UUID
cmd=
ITARGET=/
while getopts pivlud:hV OPT
do
	case $OPT in
		p) nc=cmd_package;;
		i) nc=cmd_install;;
		d) ITARGET=$OPTARG;;
		l) nc=cmd_list;;
		v) nc=cmd_verify;;
		u) nc=cmd_uninstall;;
		h) OK=Y; usage; exit;;
		V) OK=Y; version; exit;;
		*) false
	esac
	test -z "$cmd" || die "Exactly one command is required!"
	cmd=$nc
done
shift `expr $OPTIND - 1`
test -n "$ITARGET"
if test x"${ITARGET#/}" = x"$ITARGET"
then
	ITARGET=`pwd`/$ITARGET
	test x"${ITARGET#/}" != x"$ITARGET"
fi
ITARGET=${ITARGET##/}; ITARGET=/${ITARGET%%/}
if test ! -d "$ITARGET"
then
	die "Installation target directory '$ITARGET' does not exist!"
fi
test -n "$cmd" || die "Ḿissing command!"
if ! locate_config -f "$CONFIG_FILE"
then
	> "$CONFIG_FILE"
	chmod 600 -- "$CONFIG_FILE"
fi
if ! locate_config -d "$DATA_DIR"
then
	mkdir -m 700 -- "$DATA_DIR"
fi
basedir=`. "$CONFIG_FILE" && printf "%s\n" "$basedir"`
"$cmd" "$@"
OK=Y

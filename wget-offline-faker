#! /bin/sh
exit_version() {
	wr -s << ===; exit
$APP Version 2021.280.2

Copyright (c) 2021 Guenther Brunthaler. All rights reserved.

This script is free software.
Distribution is permitted under the terms of the GPLv3.
===
}
APP=`readlink -f -- "$0"` && APP=${APP##*/}

exit_help() {
	wr << ===
"$APP" is a fake-replacement for "wget".

Rather than actually downloading any files, it rather redirects any downloads
into copying files from the same directory where the script (or as a symlink
to the script) can be found.

When a requested file has not yet been downloaded for copying locally, "$APP"
creates a shell script "$fixer" in the copy source directory which contains
the "wget" commands needed to actually download the scripts to the source
directory.

In order to use the script, create a symlink named "wget" pointing to THIS
script inside the directory where the already-downloaded data files are
present.

If "$APP" is in \$PATH, this can be achieved by

$ ln -s "\`command -v $APP\`" wget

Otherwise, you need to explicitly specify where the "$APP" resides when
creating the symlink.

Alternatively, create a stub script in the download directory invoking "$APP"
like this:

===
	cat << '==='
$ cat > wget << 'EOF' && chmod +x wget
#! /bin/sh
exec wget-offline-faker -P :"$0" ${1+"$@"}
EOF

===
	wr << ===
An argument of option "-P" starting with ":" is intercepted by "$APP" in order
to provide the path of the stub script. This path needs to be known by "$APP"
when it is exec'ed by the stub script for locating the download directory. This
is not necessary when a symlink is used rather than the stub script.

After creating the symlink or stub script, make sure that the download
directory has been put within \$PATH before the directory where the real
"wget" can be found.

This can then be used to trick scripts which invokes "wget" to actually use
"$APP" instead, therefore redirecting the downloads from the files in the
local directory.

For tricking arbitrary scripts or installers, first change into to the
directory containing the "wget" symlink and the already-downloaded files, then
execute the following commands there:

$ fakepath=\$PWD:\$PATH

Now run the installer script

$ PATH=\$fakepath ./some_installer_script_using_wget

Alternatively, you can also temporarily change \$PATH like this:

$ oldpath=\$PATH; PATH=\$PWD:\$PATH; hash -r
===
	wr << ===
$ ./some_installer_script_using_wget

and later restore \$PATH like this

$ PATH=\$oldpath; hash -r; unset oldpath

so that the real "wget" will be found again.

Another usage of "$APP" is to trick "apt", "apt-get", "dpkg" and
"dpkg-reconfigure" to copy files which have already been downloaded in advance
rather than downloading them from the Internet.

Note that this is only necessary for files other than *.deb files, because
such files could be directly put into "/var/cache/apt/archives" rather than
using "$APP".

"$APP" is only useful for enforcing offline-installation of packages which
invoke "wget" in their post-installation hook scripts, such as
"rocksndiamonds" or "firmware-b43-installer".

For tricking such packages, first perform the steps explained above for
downloading the actual files into some directory and creating a "wget" symlink
there which actually points to "$APP".

Then change into that directory and excute the following commands

$ eval "`apt-config shell opath DPkg::Path`"
===
	wr << '==='
$ set -- -o DPkg::Path "$PWD:$opath"; unset opath

Then use "$@" as additional options when invoking "apt" or "apt-get" in your
command line, i. e.

$ sudo apt-get "$@" install firmware-b43-installer

or

$ sudo apt "$@" install firmware-b43-installer

This will then load the firmware file from the same directory as the script
rather than actually accessing the Internet (provided the firmware file has
already been downloaded before, of course).

This allows offline-installation of package firmware-b43-installer and
similar package downloaders which would otherwise not be supported because
they invoke wget directly in their postinstallation scripts.

The above "set" command will also set $3 to the proper $PATH containing the
fake "wget" symlink, which needs to be set for "dpkg" and "dpkg-reconfigure"
in order to make use of the fake downloader. For instance,

$ PATH=$3 sudo dpkg-reconfigure rocksndiamonds
===
	echo; exit_version
}

wr() {
	if test "$*"
	then
		fold -sw $LINEWIDTH | sed 's/[[:space:]]*$//'
	else
		{
			sep=
			while IFS= read -r line
			do
				printf %s%s "$sep" "$line"
				if test "$line"
				then
					sep=' '
				else
					echo
					test -z "$sep" && continue
					echo; sep=
				fi
			done
			test -z "$sep" || echo
		} | wr -s
	fi
}
LINEWIDTH=`
	cmd=tput; command -v $cmd > /dev/null 2>& 1 \
	&& test -t 0 && $cmd cols \
	|| echo 66
`

set -e
trap 'test $? = 0 || echo "\"$0\" failed!" >& 2' 0

# Protect arguments from shell by quoting, but only if necessary.
qin() {
	#local arg out
	for arg
	do
		case $arg in
			\#* | *\"* | *\'* | *" "* | *\|*)
				case $arg in
					*\'*) arg=\"$arg\";;
					*) arg="'$arg'"
				esac
		esac
		out=$out${out:+ }$arg
	done
	printf '%s\n' "$out"
}

# Build original command string, but filter out -P options starting with ":"
# because this script will use such options for itself for overriding the
# script path within the offline download directory.
filter_args() {
	args=
	opt_P=false
	for opt
	do
		case $opt_P in
			true)
				opt_P=false
				case $opt in
					:*) continue
				esac
				args="$args -P"
		esac
		case $opt in
			-P:*) continue;;
			-P) opt_P=true;;
			*) args="$args `qin "$opt"`"
		esac
	done
	printf '%s\n' "$args"
}

ocmd=`filter_args ${1+"$@"}`
cont=false
more=true
out=
opfx=.
script=$0
fixer=download_missing_files.sh
while getopts cO:P:hV opt
do
	case $opt in
		P)
			case $OPTARG in
				:?*)
					script=${OPTARG#:}
					test -f "$script"
					;;
				*)
					test -d "$OPTARG"
					opfx=$OPTARG
			esac
			;;
		c) cont=true;;
		O) test "$OPTARG"; out=$OPTARG;;
		h) exit_help;;
		V) exit_version;;
		*) false || exit
	esac
done
shift `expr $OPTIND - 1 || :`

ocmd=wget$ocmd
case $script in
	/*) ;;
	*) script=$PWD/$script
esac
test -f "$script"
offline_source_dir=`dirname -- "$script"`
test -d "$offline_source_dir"
fixer=$offline_source_dir/$fixer

case $# in
	0) false || exit
esac

for u
do
	case $more in
		false) false || exit
	esac
	f=${u##*/}
	case $f in
		"$u") false || exit
	esac
	src=$offline_source_dir/$f
	test -f "$src" || {
		echo "Missing downloaded offline-file: $src" >& 2
		>> "$fixer"
		printf '%s\n' "$ocmd" | sort -o "$fixer" -u - "$fixer"
		false || exit
	}
	case $out in
		'') f=$opfx/$f;;
		*) f=$out; more=false
	esac
	case $cont in
		false) test ! -e "$f"
	esac
	cp -- "$src" "$f"
done
